---
description: Architektur: modularer Monolith + Module Registry + Entitlements
alwaysApply: true
---

# Architektur (TimeAM)

## Modular, aber simpel
- Ein Deployment pro App (web/api), keine Microservices.
- Module sind Feature-Pakete im Code: src/modules/<moduleId>/...
- Es gibt eine zentrale Module-Registry (ein Ort, der Module registriert).

## Module Manifest (Konzept)
Jedes Modul definiert:
- id, displayName
- requiredEntitlements (z.B. module.time_tracking)
- (web) navItems + routes
- (api) routes + guards (auth/tenant/entitlement/permission)
- optional: calendarEventProvider

## Entitlements
- Pro Tenant gibt es Entitlements (Key/Value oder Liste).
- Backend erzwingt Entitlements bei allen Modul-Endpunkten.
- Frontend nutzt Entitlements fÃ¼r Navigation + Route-Guards.

## Kalender als Core
- Es gibt ein Core-Kalender-Modul.
- Feature-Module liefern Events Ã¼ber Provider-Schnittstelle (keine harte Kopplung).

---

# Modul-Entwicklung: Richtlinien fÃ¼r Entwickler

## WICHTIG: SaaS-Anwendung â€“ Keine Breaking Changes

**Diese Anwendung ist eine SaaS-Anwendung, in der Kunden testen. Module dÃ¼rfen NUR erweitert werden, ohne:**
- âœ… Bestehende FunktionalitÃ¤t zu beeintrÃ¤chtigen
- âœ… Datenbank-Strukturen zu Ã¤ndern (auÃŸer eigene Collections)
- âœ… API-Endpoints zu entfernen oder zu Ã¤ndern
- âœ… Frontend-Routes zu entfernen oder zu Ã¤ndern
- âœ… Shared Types zu Ã¤ndern (nur erweitern)

## Standard-Modulstruktur

### Backend (apps/api/src/modules/<moduleId>/)

Jedes Modul MUSS folgende Struktur haben:

```
modules/<moduleId>/
â”œâ”€â”€ index.ts          # Public API (exportiert Router + Types + Services)
â”œâ”€â”€ routes.ts         # Express Router mit Guards
â”œâ”€â”€ service.ts         # Business-Logik (Firestore-Operationen)
â””â”€â”€ types.ts           # Modul-spezifische Types (nur wenn nÃ¶tig)
```

**Beispiel-Struktur:**

```typescript
// index.ts
export { moduleRouter } from './routes.js';
export { createItem, getItems } from './service.js';
export type { ItemDoc, ItemResponse } from './types.js';

// routes.ts
const router = Router();
const moduleGuard = [
  requireAuth,
  requireEntitlements([ENTITLEMENT_KEYS.MODULE_XXX]),
];
router.get('/items', ...moduleGuard, async (req, res) => { ... });
export { router as moduleRouter };

// service.ts
export async function createItem(tenantId: string, ...) { ... }
export async function getItems(tenantId: string, ...) { ... }

// types.ts
export interface ItemDoc { ... }
export interface ItemResponse { ... }
```

### Frontend (apps/web/src/modules/<moduleId>/)

Jedes Modul MUSS folgende Struktur haben:

```
modules/<moduleId>/
â”œâ”€â”€ index.ts              # Public API (exportiert Page + Hooks + API)
â”œâ”€â”€ <ModuleName>Page.tsx  # Haupt-Komponente
â”œâ”€â”€ <ModuleName>Page.module.css  # Styles (CSS Modules)
â”œâ”€â”€ api.ts                # API-Calls (fetch zu Backend)
â””â”€â”€ hooks.ts              # React Hooks (optional)
```

**Beispiel-Struktur:**

```typescript
// index.ts
export { ModulePage } from './ModulePage';
export { useModuleData } from './hooks';
export * from './api';

// ModulePage.tsx
export function ModulePage() { ... }

// api.ts
export async function getItems(): Promise<ItemResponse[]> { ... }

// hooks.ts
export function useModuleData() { ... }
```

## Module-Registrierung

### 1. Backend-Router registrieren

In `apps/api/src/index.ts`:

```typescript
import { moduleRouter } from './modules/<moduleId>/index.js';
app.use('/api/<moduleId>', moduleRouter);
```

### 2. Frontend-Route registrieren

In `apps/web/src/App.tsx` oder Routing-Konfiguration:

```typescript
import { ModulePage } from './modules/<moduleId>';
<Route path="/<moduleId>" element={<ModulePage />} />
```

### 3. Module-Registry erweitern

In `packages/shared/src/types/modules.ts`:

```typescript
export const MODULE_REGISTRY: Record<string, ModuleDefinition> = {
  // ... bestehende Module
  '<moduleId>': {
    id: '<moduleId>',
    displayName: 'Modul-Name',
    description: 'Beschreibung',
    icon: 'ğŸ”§',
    category: MODULE_CATEGORY.OPTIONAL,
    entitlementKey: 'module.<module_id>',
  },
};
```

### 4. Entitlement-Key definieren

In `packages/shared/src/types/entitlements.ts`:

```typescript
export const ENTITLEMENT_KEYS = {
  // ... bestehende Keys
  MODULE_XXX: 'module.<module_id>',
} as const;
```

## Entwicklungsregeln

### âœ… ERLAUBT: Module erweitern

- âœ… Neue Module hinzufÃ¼gen
- âœ… Neue Endpoints in bestehenden Modulen hinzufÃ¼gen
- âœ… Neue Frontend-Routes hinzufÃ¼gen
- âœ… Neue Types in `packages/shared/src/types/` hinzufÃ¼gen
- âœ… Eigene Firestore-Collections erstellen: `/tenants/{tenantId}/<moduleId>/{itemId}`
- âœ… Bestehende Types erweitern (nur neue optionale Felder)

### âŒ VERBOTEN: Breaking Changes

- âŒ Bestehende API-Endpoints entfernen oder Ã¤ndern
- âŒ Bestehende Frontend-Routes entfernen oder Ã¤ndern
- âŒ Bestehende Types Ã¤ndern (nur erweitern mit optionalen Feldern)
- âŒ Bestehende Firestore-Collections Ã¤ndern (auÃŸer eigene)
- âŒ Bestehende Entitlement-Keys Ã¤ndern
- âŒ Core-Module (dashboard, calendar-core, members, notifications) Ã¤ndern
- âŒ Core-FunktionalitÃ¤t (auth, tenancy, entitlements) Ã¤ndern

### Datenbank-Regeln

**Eigene Collections:**
- âœ… Jedes Modul darf eigene Collections erstellen: `/tenants/{tenantId}/<moduleId>/...`
- âœ… Collections mÃ¼ssen IMMER tenant-scoped sein
- âœ… Collections mÃ¼ssen IMMER mit `tenantId` validiert werden

**Bestehende Collections NICHT Ã¤ndern:**
- âŒ `/tenants/{tenantId}/members` â€“ NICHT Ã¤ndern
- âŒ `/tenants/{tenantId}/entitlements` â€“ NICHT Ã¤ndern
- âŒ `/users/{uid}` â€“ NICHT Ã¤ndern
- âŒ `/tenants/{tenantId}` â€“ NICHT Ã¤ndern

### API-Endpoint-Regeln

**Neue Endpoints:**
- âœ… MÃ¼ssen IMMER `requireAuth` verwenden
- âœ… MÃ¼ssen IMMER `requireEntitlements([...])` verwenden (auÃŸer Core-Module)
- âœ… MÃ¼ssen IMMER tenant-scoped sein (tenantId aus Request)
- âœ… MÃ¼ssen IMMER Input validieren (Zod-Schemas aus `@timeam/shared`)

**Bestehende Endpoints:**
- âŒ DÃ¼rfen NICHT entfernt werden
- âŒ DÃ¼rfen NICHT geÃ¤ndert werden (nur Bugfixes)
- âŒ Response-Format darf NICHT geÃ¤ndert werden

### TypeScript-Regeln

**Shared Types (`packages/shared/src/types/`):**
- âœ… Neue Types hinzufÃ¼gen
- âœ… Bestehende Types erweitern (nur optionale Felder)
- âŒ Bestehende Types Ã¤ndern (required â†’ optional ist Breaking Change)
- âŒ Felder aus bestehenden Types entfernen

**Beispiel â€“ ERLAUBT:**
```typescript
// Vorher
interface User {
  name: string;
  email: string;
}

// Nachher (ERLAUBT)
interface User {
  name: string;
  email: string;
  phone?: string; // âœ… Neues optionales Feld
}
```

**Beispiel â€“ VERBOTEN:**
```typescript
// Vorher
interface User {
  name: string;
  email: string;
}

// Nachher (VERBOTEN)
interface User {
  name: string;
  // âŒ email entfernt
  phone: string; // âŒ email durch phone ersetzt
}
```

### Frontend-Regeln

**Neue Komponenten:**
- âœ… MÃ¼ssen CSS Modules verwenden (`.module.css`)
- âœ… MÃ¼ssen Error Boundaries verwenden (ModuleBoundary)
- âœ… MÃ¼ssen Entitlement-Checks haben (Route Guards)

**Bestehende Komponenten:**
- âŒ DÃ¼rfen NICHT entfernt werden
- âŒ Props dÃ¼rfen NICHT geÃ¤ndert werden (nur erweitern)
- âŒ Routes dÃ¼rfen NICHT geÃ¤ndert werden

### Testing-Regeln

**Vor jedem Commit:**
- âœ… `npm run build` muss ohne Fehler laufen
- âœ… `npm run typecheck` muss ohne Fehler laufen
- âœ… Shared-Paket muss zuerst gebaut werden: `npm run build -w @timeam/shared`
- âœ… Alle TypeScript-Fehler mÃ¼ssen behoben sein

**SaaS-Umgebung:**
- âš ï¸ Module werden in einer Live-Umgebung getestet
- âš ï¸ Breaking Changes kÃ¶nnen Kunden beeintrÃ¤chtigen
- âš ï¸ Immer rÃ¼ckwÃ¤rtskompatibel bleiben

## Checkliste fÃ¼r neue Module

- [ ] Modul-Struktur erstellt (Backend + Frontend)
- [ ] Module-Registry erweitert (`packages/shared/src/types/modules.ts`)
- [ ] Entitlement-Key definiert (`packages/shared/src/types/entitlements.ts`)
- [ ] Backend-Router registriert (`apps/api/src/index.ts`)
- [ ] Frontend-Route registriert (`apps/web/src/App.tsx`)
- [ ] Alle Guards implementiert (auth + tenant + entitlement)
- [ ] Tenant-Scope validiert (alle DB-Operationen)
- [ ] Input-Validierung implementiert (Zod-Schemas)
- [ ] TypeScript-Fehler behoben
- [ ] Build erfolgreich (`npm run build`)
- [ ] Keine Breaking Changes zu bestehenden Modulen

## Beispiel: Neues Modul erstellen

Siehe bestehende Module als Referenz:
- `apps/api/src/modules/time-tracking/` (Backend)
- `apps/web/src/modules/time-tracking/` (Frontend)
- `packages/shared/src/types/modules.ts` (Registry)

**WICHTIG:** Kopiere die Struktur, passe sie an, aber Ã¤ndere KEINE bestehenden Module!